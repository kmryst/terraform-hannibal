name: Deploy NestJS Hannibal (Enterprise)

env:
  AWS_ACCOUNT_ID: "258632448142"
  PROJECT_NAME: "nestjs-hannibal-3"
  AWS_REGION: "ap-northeast-1"
  TERRAFORM_VERSION: "1.12.1"
  NODE_VERSION: "20"

on:
  workflow_dispatch:
    inputs:
      deployment_mode:
        description: "ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¢ãƒ¼ãƒ‰ã‚’é¸æŠž"
        required: true
        default: "provisioning"
        type: choice
        options:
          - provisioning   # 0å›žç›®ï¼ˆåˆæœŸæ§‹ç¯‰ãƒ»Blueã®ã¿ï¼‰
          - bluegreen      # 1å›žç›®ä»¥é™ï¼ˆBlue/Greenåˆ‡æ›¿ï¼‰

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json
      - name: Install backend dependencies
        run: npm ci
      - name: Run backend tests
        run: npm test
      - name: Setup Node.js for client
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: client/package-lock.json
      - name: Install client dependencies
        run: npm ci
        working-directory: ./client

  deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install prerequisites
        run: |
          sudo apt-get update
          sudo apt-get install -y jq unzip
          jq --version

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false
        env:
          TF_PLUGIN_CACHE_DIR: ~/.terraform.d/plugin-cache

      - name: Verify Terraform installation
        run: |
          terraform version
          which terraform

      - name: Assume CICD Role
        run: |
          set -e
          ROLE_ARN="arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/HannibalCICDRole-Dev"
          SESSION_NAME="github-actions-deploy-$(date +%s)"
          CREDS=$(aws sts assume-role \
            --role-arn "$ROLE_ARN" \
            --role-session-name "$SESSION_NAME" \
            --output json)
          echo "AWS_ACCESS_KEY_ID=$(echo "$CREDS" | jq -r '.Credentials.AccessKeyId')" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(echo "$CREDS" | jq -r '.Credentials.SecretAccessKey')" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=$(echo "$CREDS" | jq -r '.Credentials.SessionToken')" >> $GITHUB_ENV

      - name: Deploy Backend Infrastructure
        working-directory: ./terraform/backend
        run: |
          set -e
          terraform init -input=false
          terraform plan \
            -var="client_url_for_cors=https://hamilcar-hannibal.click" \
            -var="environment=dev" \
            -out=tfplan
          terraform apply -auto-approve tfplan
          terraform output -json > ../../tf_outputs_backend.json

      - name: Deploy Frontend Infrastructure
        working-directory: ./terraform/frontend
        run: |
          set -e
          terraform init -input=false
          ALB_DNS=$(jq -r '.alb_dns_name.value' ../../tf_outputs_backend.json)
          terraform plan \
            -var="api_alb_dns_name=$ALB_DNS" \
            -var="environment=dev" \
            -var="enable_cloudfront=true" \
            -out=tfplan
          terraform apply -auto-approve tfplan
          terraform output -json > ../../tf_outputs_frontend.json

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push ECS Image
        run: |
          set -e
          NEW_IMAGE="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.PROJECT_NAME }}:${{ github.sha }}"
          docker build -t "$NEW_IMAGE" .
          docker push "$NEW_IMAGE"
          echo "NEW_IMAGE=$NEW_IMAGE" >> $GITHUB_ENV

      - name: Generate AppSpec for ECS CodeDeploy
        run: |
          set -e
          aws ecs describe-task-definition \
            --task-definition "${{ env.PROJECT_NAME }}-api-task" \
            --query 'taskDefinition' > current_task_def.json
          CONTAINER_NAME=$(jq -r '.containerDefinitions[0].name' current_task_def.json)
          CONTAINER_PORT=$(jq -r '.containerDefinitions[0].portMappings[0].containerPort' current_task_def.json)
          jq --arg IMAGE "$NEW_IMAGE" \
            '.containerDefinitions[0].image = $IMAGE |
             del(.taskDefinitionArn, .revision, .status,
                 .requiresAttributes, .placementConstraints,
                 .compatibilities, .registeredAt, .registeredBy)' \
            current_task_def.json > new_task_def.json
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new_task_def.json \
            --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "NEW_TASK_DEF_ARN=$NEW_TASK_DEF_ARN" >> $GITHUB_ENV
          cat > appspec.yaml << EOF
          version: 0.0
          Resources:
            - TargetService:
                Type: AWS::ECS::Service
                Properties:
                  TaskDefinition: $NEW_TASK_DEF_ARN
                  LoadBalancerInfo:
                    ContainerName: "$CONTAINER_NAME"
                    ContainerPort: $CONTAINER_PORT
          EOF

      - name: Deploy with CodeDeploy Blue/Green
        if: ${{ inputs.deployment_mode == 'bluegreen' }}
        run: |
          set -e
          S3_BUCKET="${{ env.PROJECT_NAME }}-codedeploy-artifacts"
          S3_KEY="appspec-${{ github.sha }}.yaml"
          aws s3 cp appspec.yaml "s3://$S3_BUCKET/$S3_KEY"
          DEPLOYMENT_ID=$(aws deploy create-deployment \
            --application-name "${{ env.PROJECT_NAME }}-app" \
            --deployment-group-name "${{ env.PROJECT_NAME }}-dg" \
            --s3-location bucket="$S3_BUCKET",key="$S3_KEY",bundleType="YAML" \
            --query 'deploymentId' --output text)
          echo "ðŸš€ CodeDeploy deployment started: $DEPLOYMENT_ID"
          aws deploy wait deployment-successful --deployment-id "$DEPLOYMENT_ID"
          echo "âœ… Deployment finished"
