name: Deploy NestJS Hannibal (Enterprise)

env:
  AWS_ACCOUNT_ID: "258632448142"
  PROJECT_NAME: "nestjs-hannibal-3"
  AWS_REGION: "ap-northeast-1"
  TERRAFORM_VERSION: "1.12.1"
  NODE_VERSION: "20"

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json
      - name: Install backend dependencies
        run: npm ci
      - name: Run backend tests
        run: npm test
      - name: Setup Node.js for client
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: client/package-lock.json
      - name: Install client dependencies
        run: npm ci
        working-directory: ./client

  deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install prerequisites
        run: |
          sudo apt-get update
          sudo apt-get install -y jq unzip
          jq --version

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false
        env:
          TF_PLUGIN_CACHE_DIR: ~/.terraform.d/plugin-cache
      
      - name: Verify Terraform installation
        run: |
          terraform version
          which terraform

      - name: Assume CICD Role
        run: |
          set -e
          ROLE_ARN="arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/HannibalCICDRole-Dev"
          SESSION_NAME="github-actions-deploy-$(date +%s)"
          
          echo "Assuming role: $ROLE_ARN"
          CREDS=$(aws sts assume-role \
            --role-arn "$ROLE_ARN" \
            --role-session-name "$SESSION_NAME" \
            --output json)
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Failed to assume role"
            exit 1
          fi
          
          echo "AWS_ACCESS_KEY_ID=$(echo "$CREDS" | jq -r '.Credentials.AccessKeyId')" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(echo "$CREDS" | jq -r '.Credentials.SecretAccessKey')" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=$(echo "$CREDS" | jq -r '.Credentials.SessionToken')" >> $GITHUB_ENV
          echo "‚úÖ Successfully assumed CICD role"

      - name: Deploy Backend Infrastructure
        working-directory: ./terraform/backend
        run: |
          set -e
          echo "üöÄ Initializing Terraform backend..."
          terraform init -input=false
          
          echo "üìã Planning Terraform changes..."
          terraform plan \
            -var="client_url_for_cors=https://hamilcar-hannibal.click" \
            -var="environment=${{ github.event.inputs.environment || 'dev' }}" \
            -out=tfplan
          
          echo "üèóÔ∏è Applying Terraform changes..."
          terraform apply -auto-approve tfplan
          
          echo "üì§ Exporting Terraform outputs..."
          terraform output -json > ../../tf_outputs_backend.json
          
          if [ ! -f "../../tf_outputs_backend.json" ]; then
            echo "‚ùå Failed to generate backend outputs"
            exit 1
          fi
          
          echo "‚úÖ Backend infrastructure deployed successfully"

      - name: Deploy Frontend Infrastructure
        working-directory: ./terraform/frontend
        run: |
          set -e
          echo "üöÄ Initializing Terraform frontend..."
          terraform init -input=false
          
          # Validate backend outputs exist
          if [ ! -f "../../tf_outputs_backend.json" ]; then
            echo "‚ùå Backend outputs not found"
            exit 1
          fi
          
          ALB_DNS=$(jq -r '.alb_dns_name.value' ../../tf_outputs_backend.json)
          if [ "$ALB_DNS" = "null" ] || [ -z "$ALB_DNS" ]; then
            echo "‚ùå ALB DNS name not found in backend outputs"
            exit 1
          fi
          
          echo "üìã Planning frontend changes with ALB: $ALB_DNS"
          terraform plan \
            -var="api_alb_dns_name=$ALB_DNS" \
            -var="environment=${{ github.event.inputs.environment || 'dev' }}" \
            -var="enable_cloudfront=true" \
            -out=tfplan
          
          echo "üèóÔ∏è Applying frontend changes..."
          terraform apply -auto-approve tfplan
          
          echo "üì§ Exporting frontend outputs..."
          terraform output -json > ../../tf_outputs_frontend.json
          echo "‚úÖ Frontend infrastructure deployed successfully"

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push ECS Image
        run: |
          set -e
          NEW_IMAGE="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.PROJECT_NAME }}:${{ github.sha }}"
          echo "üê≥ Building Docker image: $NEW_IMAGE"
          
          docker build -t "$NEW_IMAGE" .
          if [ $? -ne 0 ]; then
            echo "‚ùå Docker build failed"
            exit 1
          fi
          
          echo "üì§ Pushing Docker image..."
          docker push "$NEW_IMAGE"
          if [ $? -ne 0 ]; then
            echo "‚ùå Docker push failed"
            exit 1
          fi
          
          echo "NEW_IMAGE=$NEW_IMAGE" >> $GITHUB_ENV
          echo "‚úÖ Docker image built and pushed successfully"

      - name: Retrieve Terraform Outputs for CodeDeploy
        working-directory: ./terraform/backend
        run: |
          set -e
          echo "üìã Retrieving Terraform outputs for CodeDeploy..."
          
          PROD_LISTENER_ARN=$(terraform output -raw production_listener_arn 2>/dev/null || echo "")
          TEST_LISTENER_ARN=$(terraform output -raw test_listener_arn 2>/dev/null || echo "")
          BLUE_TG_NAME=$(terraform output -raw blue_target_group_name 2>/dev/null || echo "")
          GREEN_TG_NAME=$(terraform output -raw green_target_group_name 2>/dev/null || echo "")
          
          # Validate required outputs
          if [ -z "$PROD_LISTENER_ARN" ] || [ -z "$TEST_LISTENER_ARN" ] || [ -z "$BLUE_TG_NAME" ] || [ -z "$GREEN_TG_NAME" ]; then
            echo "‚ùå Missing required Terraform outputs for CodeDeploy"
            echo "Production Listener: $PROD_LISTENER_ARN"
            echo "Test Listener: $TEST_LISTENER_ARN"
            echo "Blue Target Group: $BLUE_TG_NAME"
            echo "Green Target Group: $GREEN_TG_NAME"
            exit 1
          fi
          
          echo "PROD_LISTENER_ARN=$PROD_LISTENER_ARN" >> $GITHUB_ENV
          echo "TEST_LISTENER_ARN=$TEST_LISTENER_ARN" >> $GITHUB_ENV
          echo "BLUE_TG_NAME=$BLUE_TG_NAME" >> $GITHUB_ENV
          echo "GREEN_TG_NAME=$GREEN_TG_NAME" >> $GITHUB_ENV
          echo "‚úÖ CodeDeploy outputs retrieved successfully"

      - name: Describe Current Task Definition
        run: |
          set -e
          echo "üìã Retrieving current ECS task definition..."
          
          aws ecs describe-task-definition \
            --task-definition "${{ env.PROJECT_NAME }}-api-task" \
            --query 'taskDefinition' > current_task_def.json
          
          if [ $? -ne 0 ] || [ ! -f "current_task_def.json" ]; then
            echo "‚ùå Failed to retrieve task definition"
            exit 1
          fi
          
          echo "‚úÖ Current task definition retrieved successfully"

      - name: Register New Task Definition
        run: |
          set -e
          echo "üîÑ Creating new task definition with image: $NEW_IMAGE"
          
          # Create new task definition with updated image
          jq --arg IMAGE "$NEW_IMAGE" \
            '.containerDefinitions[0].image = $IMAGE |
             del(.taskDefinitionArn, .revision, .status,
                 .requiresAttributes, .placementConstraints,
                 .compatibilities, .registeredAt, .registeredBy)' \
            current_task_def.json > new_task_def.json
          
          if [ $? -ne 0 ] || [ ! -f "new_task_def.json" ]; then
            echo "‚ùå Failed to create new task definition JSON"
            exit 1
          fi
          
          echo "üìù Registering new task definition..."
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new_task_def.json \
            --query 'taskDefinition.taskDefinitionArn' --output text)
          
          if [ $? -ne 0 ] || [ -z "$NEW_TASK_DEF_ARN" ]; then
            echo "‚ùå Failed to register new task definition"
            exit 1
          fi
          
          echo "NEW_TASK_DEF_ARN=$NEW_TASK_DEF_ARN" >> $GITHUB_ENV
          echo "‚úÖ New task definition registered: $NEW_TASK_DEF_ARN"

      - name: Generate appspec.json
        run: |
          set -e
          echo "üìù Generating AppSpec for CodeDeploy..."
          
          # Validate required environment variables
          if [ -z "$NEW_TASK_DEF_ARN" ]; then
            echo "‚ùå NEW_TASK_DEF_ARN is not set"
            exit 1
          fi
          
          # Generate AppSpec JSON with proper escaping
          cat > appspec.json << EOF
          {
            "version": "1.0",
            "Resources": [
              {
                "TargetService": {
                  "Type": "AWS::ECS::Service",
                  "Properties": {
                    "TaskDefinition": "$NEW_TASK_DEF_ARN",
                    "LoadBalancerInfo": {
                      "ContainerName": "${{ env.PROJECT_NAME }}-container",
                      "ContainerPort": 3000
                    },
                    "PlatformVersion": "LATEST"
                  }
                }
              }
            ],
            "Hooks": [
              { "BeforeInstall": "echo 'Starting Blue/Green deployment preparation'" },
              { "AfterInstall": "echo 'New task definition registered successfully'" },
              { "AfterAllowTestTraffic": "echo 'Test traffic validation completed'" },
              { "BeforeAllowTraffic": "echo 'Preparing production traffic switch'" },
              { "AfterAllowTraffic": "echo 'Production traffic switch completed successfully'" }
            ]
          }
          EOF
          
          # Validate JSON syntax
          if ! jq empty appspec.json 2>/dev/null; then
            echo "‚ùå Generated AppSpec JSON is invalid"
            cat appspec.json
            exit 1
          fi
          
          echo "‚úÖ AppSpec generated successfully"
          jq . appspec.json

      - name: Create CodeDeploy Deployment
        run: |
          set -e
          echo "üöÄ Initiating CodeDeploy Blue/Green deployment..."
          
          # Validate AppSpec exists and is valid JSON
          if [ ! -f "appspec.json" ]; then
            echo "‚ùå AppSpec file not found"
            exit 1
          fi
          
          if ! jq empty appspec.json 2>/dev/null; then
            echo "‚ùå AppSpec JSON is invalid"
            exit 1
          fi
          
          # Create revision JSON with proper escaping
          REV_JSON=$(jq -c . appspec.json)
          if [ $? -ne 0 ] || [ -z "$REV_JSON" ]; then
            echo "‚ùå Failed to compress AppSpec JSON"
            exit 1
          fi
          
          echo "üìã Creating deployment with revision..."
          DEPLOYMENT_ID=$(aws deploy create-deployment \
            --application-name "${{ env.PROJECT_NAME }}-codedeploy-app" \
            --deployment-group-name "${{ env.PROJECT_NAME }}-deployment-group" \
            --deployment-config-name "CodeDeployDefault.ECSAllAtOnce" \
            --revision "{\"revisionType\":\"AppSpecContent\",\"appSpecContent\":{\"content\":\"$REV_JSON\"}}" \
            --query 'deploymentId' --output text)
          
          if [ $? -ne 0 ] || [ -z "$DEPLOYMENT_ID" ]; then
            echo "‚ùå Failed to create CodeDeploy deployment"
            exit 1
          fi
          
          echo "DEPLOYMENT_ID=$DEPLOYMENT_ID" >> $GITHUB_ENV
          echo "‚úÖ Deployment initiated: $DEPLOYMENT_ID"
          echo "üìà Monitor at: https://console.aws.amazon.com/codesuite/codedeploy/deployments/$DEPLOYMENT_ID"
          
      - name: Monitor Deployment Status
        run: |
          set -e
          echo "‚è≥ Monitoring deployment status..."
          
          TIMEOUT=1800  # 30 minutes
          ELAPSED=0
          INTERVAL=30
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            STATUS=$(aws deploy get-deployment \
              --deployment-id "$DEPLOYMENT_ID" \
              --query 'deploymentInfo.status' --output text)
            
            echo "[$(date '+%H:%M:%S')] Deployment status: $STATUS"
            
            case "$STATUS" in
              "Succeeded")
                echo "‚úÖ Deployment completed successfully!"
                exit 0
                ;;
              "Failed"|"Stopped")
                echo "‚ùå Deployment failed with status: $STATUS"
                aws deploy get-deployment --deployment-id "$DEPLOYMENT_ID" --query 'deploymentInfo.errorInformation'
                exit 1
                ;;
              "InProgress"|"Queued"|"Ready")
                echo "‚è≥ Deployment in progress..."
                ;;
              *)
                echo "‚ö†Ô∏è Unknown deployment status: $STATUS"
                ;;
            esac
            
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done
          
          echo "‚ùå Deployment timed out after $((TIMEOUT/60)) minutes"
          exit 1
