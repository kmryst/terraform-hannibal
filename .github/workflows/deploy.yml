name: Deploy NestJS Hannibal (Enterprise)

env:
  AWS_ACCOUNT_ID: "258632448142"
  PROJECT_NAME: "nestjs-hannibal-3"
  AWS_REGION: "ap-northeast-1"
  TERRAFORM_VERSION: "1.12.1"
  NODE_VERSION: "20"

on:
  workflow_dispatch:
    inputs:
      run_codedeploy:
        description: "CodeDeployã‚’å®Ÿè¡Œã™ã‚‹ã‹ (true=Blue/Greenãƒ‡ãƒ—ãƒ­ã‚¤, false=0å›ç›®ã¯Blueã®ã¿ç¨¼åƒ)"
        required: true
        default: false
        type: boolean

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json
      - name: Install backend dependencies
        run: npm ci
      - name: Run backend tests
        run: npm test
      - name: Setup Node.js for client
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: client/package-lock.json
      - name: Install client dependencies
        run: npm ci
        working-directory: ./client

  deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install prerequisites
        run: |
          sudo apt-get update
          sudo apt-get install -y jq unzip
          jq --version

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false
        env:
          TF_PLUGIN_CACHE_DIR: ~/.terraform.d/plugin-cache
      
      - name: Verify Terraform installation
        run: |
          terraform version
          which terraform

      - name: Assume CICD Role
        run: |
          set -e
          ROLE_ARN="arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/HannibalCICDRole-Dev"
          SESSION_NAME="github-actions-deploy-$(date +%s)"
          
          echo "Assuming role: $ROLE_ARN"
          CREDS=$(aws sts assume-role \
            --role-arn "$ROLE_ARN" \
            --role-session-name "$SESSION_NAME" \
            --output json)
          
          if [ $? -ne 0 ]; then
            echo "âŒ Failed to assume role"
            exit 1
          fi
          
          echo "AWS_ACCESS_KEY_ID=$(echo "$CREDS" | jq -r '.Credentials.AccessKeyId')" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(echo "$CREDS" | jq -r '.Credentials.SecretAccessKey')" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=$(echo "$CREDS" | jq -r '.Credentials.SessionToken')" >> $GITHUB_ENV
          echo "âœ… Successfully assumed CICD role"

      - name: Deploy Backend Infrastructure
        working-directory: ./terraform/backend
        run: |
          set -e
          echo "ğŸš€ Initializing Terraform backend..."
          terraform init -input=false
          
          echo "ğŸ“‹ Planning Terraform changes..."
          terraform plan \
            -var="client_url_for_cors=https://hamilcar-hannibal.click" \
            -var="environment=dev" \
            -out=tfplan
          
          echo "ğŸ—ï¸ Applying Terraform changes..."
          terraform apply -auto-approve tfplan
          
          echo "ğŸ“¤ Exporting Terraform outputs..."
          terraform output -json > ../../tf_outputs_backend.json
          
          if [ ! -f "../../tf_outputs_backend.json" ]; then
            echo "âŒ Failed to generate backend outputs"
            exit 1
          fi
          
          echo "âœ… Backend infrastructure deployed successfully"

      - name: Deploy Frontend Infrastructure
        working-directory: ./terraform/frontend
        run: |
          set -e
          echo "ğŸš€ Initializing Terraform frontend..."
          terraform init -input=false
          
          # Validate backend outputs exist
          if [ ! -f "../../tf_outputs_backend.json" ]; then
            echo "âŒ Backend outputs not found"
            exit 1
          fi
          
          ALB_DNS=$(jq -r '.alb_dns_name.value' ../../tf_outputs_backend.json)
          if [ "$ALB_DNS" = "null" ] || [ -z "$ALB_DNS" ]; then
            echo "âŒ ALB DNS name not found in backend outputs"
            exit 1
          fi
          
          echo "ğŸ“‹ Planning frontend changes with ALB: $ALB_DNS"
          terraform plan \
            -var="api_alb_dns_name=$ALB_DNS" \
            -var="environment=dev" \
            -var="enable_cloudfront=true" \
            -out=tfplan
          
          echo "ğŸ—ï¸ Applying frontend changes..."
          terraform apply -auto-approve tfplan
          
          echo "ğŸ“¤ Exporting frontend outputs..."
          terraform output -json > ../../tf_outputs_frontend.json
          echo "âœ… Frontend infrastructure deployed successfully"

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push ECS Image
        run: |
          set -e
          NEW_IMAGE="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.PROJECT_NAME }}:${{ github.sha }}"
          echo "ğŸ³ Building Docker image: $NEW_IMAGE"
          
          docker build -t "$NEW_IMAGE" .
          if [ $? -ne 0 ]; then
            echo "âŒ Docker build failed"
            exit 1
          fi
          
          echo "ğŸ“¤ Pushing Docker image..."
          docker push "$NEW_IMAGE"
          if [ $? -ne 0 ]; then
            echo "âŒ Docker push failed"
            exit 1
          fi
          
          echo "NEW_IMAGE=$NEW_IMAGE" >> $GITHUB_ENV
          echo "âœ… Docker image built and pushed successfully"

      # appspec.yamlç”Ÿæˆã¾ã§ã¯å¸¸ã«å®Ÿè¡Œï¼ˆæ¤œè¨¼ã«ã‚‚æ´»ç”¨å¯èƒ½ï¼‰
      - name: Generate AppSpec for ECS CodeDeploy (dynamic)
        run: |
          set -e
          echo "ğŸ“ Generating appspec.yaml dynamically..."
          aws ecs describe-task-definition \
            --task-definition "${{ env.PROJECT_NAME }}-api-task" \
            --query 'taskDefinition' > current_task_def.json
          
          CONTAINER_NAME=$(jq -r '.containerDefinitions[0].name' current_task_def.json)
          CONTAINER_PORT=$(jq -r '.containerDefinitions[0].portMappings[0].containerPort' current_task_def.json)

          if [ -z "$CONTAINER_NAME" ] || [ -z "$CONTAINER_PORT" ] || [ "$CONTAINER_NAME" = "null" ] || [ "$CONTAINER_PORT" = "null" ]; then
            echo "âŒ Failed to parse container name/port from task definition"
            exit 1
          fi

          # æ–°ã—ã„ã‚¿ã‚¹ã‚¯å®šç¾©ã‚‚å…ˆã«ç™»éŒ²ï¼ˆCodeDeployã‚’å®Ÿè¡Œã—ãªã„å ´åˆã§ã‚‚æ¤œè¨¼ç”¨é€”ã§å¯ï¼‰
          jq --arg IMAGE "$NEW_IMAGE" \
            '.containerDefinitions[0].image = $IMAGE |
             del(.taskDefinitionArn, .revision, .status,
                 .requiresAttributes, .placementConstraints,
                 .compatibilities, .registeredAt, .registeredBy)' \
            current_task_def.json > new_task_def.json

          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new_task_def.json \
            --query 'taskDefinition.taskDefinitionArn' --output text)

          if [ -z "$NEW_TASK_DEF_ARN" ]; then
            echo "âŒ Failed to register new task definition"
            exit 1
          fi

          cat > appspec.yaml << EOF
          version: 0.0
          Resources:
            - TargetService:
                Type: AWS::ECS::Service
                Properties:
                  TaskDefinition: $NEW_TASK_DEF_ARN
                  LoadBalancerInfo:
                    ContainerName: "$CONTAINER_NAME"
                    ContainerPort: $CONTAINER_PORT
          EOF

          echo "âœ… appspec.yaml generated and task definition registered."
          echo "NEW_TASK_DEF_ARN=$NEW_TASK_DEF_ARN" >> $GITHUB_ENV

      # 1å›ç›®ä»¥é™ã®ã¿CodeDeployã‚’å®Ÿè¡Œï¼ˆ0å›ç›®ã¯ã‚¹ã‚­ãƒƒãƒ—ï¼‰
      - name: Deploy with CodeDeploy Blue/Green
        if: ${{ inputs.run_codedeploy == true }}
        run: |
          set -e
          echo "ğŸš€ Starting CodeDeploy Blue/Green deployment..."

          if [ -z "${{ env.NEW_TASK_DEF_ARN }}" ]; then
            echo "âŒ NEW_TASK_DEF_ARN is not set"
            exit 1
          fi
          
          # Upload appspec to S3
          S3_BUCKET="${{ env.PROJECT_NAME }}-codedeploy-artifacts"
          S3_KEY="appspec-${{ github.sha }}.yaml"
          aws s3 cp appspec.yaml "s3://$S3_BUCKET/$S3_KEY"
          
          if [ $? -ne 0 ]; then
            echo "âŒ Failed to upload appspec to S3"
            exit 1
          fi
          
          # Start CodeDeploy deployment
          DEPLOYMENT_ID=$(aws deploy create-deployment \
            --application-name "${{ env.PROJECT_NAME }}-app" \
            --deployment-group-name "${{ env.PROJECT_NAME }}-dg" \
            --s3-location bucket="$S3_BUCKET",key="$S3_KEY",bundleType="YAML" \
            --query 'deploymentId' --output text)
          
          if [ $? -ne 0 ] || [ -z "$DEPLOYMENT_ID" ]; then
            echo "âŒ Failed to create CodeDeploy deployment"
            exit 1
          fi
          
          echo "ğŸš€ CodeDeploy deployment started: $DEPLOYMENT_ID"
          echo "ğŸ“Š Monitor deployment: https://console.aws.amazon.com/codesuite/codedeploy/deployments/$DEPLOYMENT_ID"
          
          # Wait for deployment to complete
          echo "â³ Waiting for Blue/Green deployment to complete..."
          aws deploy wait deployment-successful --deployment-id "$DEPLOYMENT_ID"
          
          if [ $? -eq 0 ]; then
            echo "âœ… CodeDeploy Blue/Green deployment completed successfully!"
            echo "ğŸŒ Production URL: http://$(jq -r '.alb_dns_name.value' tf_outputs_backend.json)"
            echo "ğŸ§ª Test URL: http://$(jq -r '.alb_dns_name.value' tf_outputs_backend.json):8080"
          else
            echo "âŒ CodeDeploy deployment failed or timed out"
            aws deploy get-deployment --deployment-id "$DEPLOYMENT_ID" --query 'deploymentInfo.errorInformation'
            exit 1
          fi
