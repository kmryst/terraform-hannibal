# .github/workflows/deploy.yml (-e オプション削除 & exit 1 コメントアウト版)

name: Deploy NestJS Hannibal App

on:
  pull_request:
    branches: [feature/github-actions] # トリガーブランチ
  push:
    branches: [feature/github-actions] # トリガーブランチ

jobs:
  test:
    # (変更なし)
    runs-on: ubuntu-latest # このジョブを実行する仮想マシン
    steps: # step: 手順
      - name: Checkout code
        uses: actions/checkout@v4 # GitHubが提供する公式アクションで、リポジトリのコードをチェックアウト（取得）します
      - name: Setup Node.js for Backend
        uses: actions/setup-node@v3 # GitHubが提供する公式アクションで、指定したバージョンのNode.jsをインストールします
        with: # usesで指定したアクションに渡すパラメータ（設定値）を定義するキーワードです
          node-version: '16'
          cache: 'npm' # npmのキャッシュを有効にすることで、依存関係のダウンロードを高速化します
          cache-dependency-path: package-lock.json
      - name: Install Backend Dependencies
        run: npm ci
      - name: Run Backend Tests
        run: npm test
      - name: Setup Node.js for Frontend
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: client/package-lock.json
      - name: Install Frontend Dependencies
        run: npm ci
        working-directory: ./client
      - name: Run Frontend Tests
        run: echo "Frontend tests would run here (e.g., npm run test)"
        working-directory: ./client

  deploy:
    # (変更なし)
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/feature/github-actions'
    runs-on: ubuntu-latest
    outputs:
      s3_bucket_name: ${{ steps.get_terraform_outputs.outputs.s3_bucket_name }}
      cloudfront_distribution_id: ${{ steps.get_terraform_outputs.outputs.cloudfront_distribution_id }}
      ec2_instance_id: ${{ steps.get_terraform_outputs.outputs.ec2_instance_id }}
      backend_eip_address: ${{ steps.get_terraform_outputs.outputs.backend_eip_address }}
      cloudfront_domain_name: ${{ steps.get_terraform_outputs.outputs.cloudfront_domain_name }}

    steps:
      # (以前のステップは変更なし)
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-1
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.0.0
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq
      - name: Terraform Init (Backend)
        id: init-backend
        run: terraform init
        working-directory: ./terraform/backend
      - name: Terraform Plan (Backend)
        id: plan-backend
        run: terraform plan -no-color -var="client_url_for_cors="
        working-directory: ./terraform/backend
        continue-on-error: true
      - name: Terraform Apply (Backend)
        id: apply-backend
        run: terraform apply -auto-approve -no-color -var="client_url_for_cors="
        working-directory: ./terraform/backend
      - name: Terraform Init (Frontend)
        id: init-frontend
        run: terraform init
        working-directory: ./terraform/frontend
      - name: Terraform Plan (Frontend)
        id: plan-frontend
        run: terraform plan -no-color -var="api_alb_dns_name=$(jq -r '.alb_dns_name.value' ./terraform/backend/tf_outputs_backend.json)"
        working-directory: ./terraform/frontend
        continue-on-error: true
      - name: Terraform Apply (Frontend)
        id: apply-frontend
        run: terraform apply -auto-approve -no-color -var="api_alb_dns_name=$(jq -r '.alb_dns_name.value' ./terraform/backend/tf_outputs_backend.json)"
        working-directory: ./terraform/frontend
      - name: Get Terraform Outputs (Frontend)
        id: get_terraform_outputs
        run: |
          echo "Retrieving Terraform outputs (frontend)..."
          cd ./terraform/frontend
          terraform output -json > tf_outputs.json
          echo "--- Terraform Outputs (JSON) ---"
          cat tf_outputs.json
          echo "--------------------------------"
          cd ../..
          echo "s3_bucket_name=$(jq -r '.s3_bucket_name.value' ./terraform/frontend/tf_outputs.json)" >> $GITHUB_OUTPUT
          echo "cloudfront_domain_name=$(jq -r '.cloudfront_domain_name.value' ./terraform/frontend/tf_outputs.json)" >> $GITHUB_OUTPUT
          echo "cloudfront_distribution_id=$(jq -r '.cloudfront_distribution_id.value' ./terraform/frontend/tf_outputs.json)" >> $GITHUB_OUTPUT
          echo "::set-output name=s3_bucket_name::$(jq -r '.s3_bucket_name.value' ./terraform/frontend/tf_outputs.json)"
          echo "::set-output name=cloudfront_domain_name::$(jq -r '.cloudfront_domain_name.value' ./terraform/frontend/tf_outputs.json)"
          echo "::set-output name=cloudfront_distribution_id::$(jq -r '.cloudfront_distribution_id.value' ./terraform/frontend/tf_outputs.json)"
        working-directory: ./
      # CloudFrontドメイン名をCORS用にbackendへ再適用
      - name: Terraform Apply (Backend, CORS Update)
        id: apply-backend-cors
        run: terraform apply -auto-approve -no-color -var="client_url_for_cors=https://${{ steps.get_terraform_outputs.outputs.cloudfront_domain_name }}"
        working-directory: ./terraform/backend
      - name: Setup Node.js for Frontend Build
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: client/package-lock.json
      - name: Install Frontend Dependencies for Build
        run: npm ci
        working-directory: ./client
      - name: Build Frontend
        run: npm run build
        working-directory: ./client
      - name: Deploy Frontend to S3
        run: |
          # (内容は変更なし)
          S3_BUCKET="${{ steps.get_terraform_outputs.outputs.s3_bucket_name }}"
          if [ -z "$S3_BUCKET" ]; then echo "::error::S3 bucket name not found."; exit 1; fi # ここでのexitは残す
          echo "Deploying frontend to bucket: $S3_BUCKET"
          aws s3 sync ./client/dist "s3://$S3_BUCKET" --delete
      - name: Invalidate CloudFront Cache
        run: |
          # (内容は変更なし)
          CF_DIST_ID="${{ steps.get_terraform_outputs.outputs.cloudfront_distribution_id }}"
          if [ -z "$CF_DIST_ID" ]; then echo "::error::CloudFront distribution ID not found."; exit 1; fi # ここでのexitは残す
          echo "Invalidating CloudFront cache for distribution: $CF_DIST_ID"
          aws cloudfront create-invalidation --distribution-id "$CF_DIST_ID" --paths "/*"

      # --- ★★★ ECS Fargate/ECRへのバックエンドデプロイ ★★★ ---
      - name: Login to Amazon ECR
        id: login_ecr
        uses: aws-actions/amazon-ecr-login@v2
      - name: Build, Tag, and Push Docker image to ECR
        env:
          ECR_REGISTRY: 258632448142.dkr.ecr.ap-northeast-1.amazonaws.com
          ECR_REPOSITORY: nestjs-hannibal-3
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
      - name: Update ECS Service to use new image
        env:
          AWS_REGION: ap-northeast-1
          CLUSTER_NAME: nestjs-hannibal-3-cluster
          SERVICE_NAME: nestjs-hannibal-3-api-service
          TASK_FAMILY: nestjs-hannibal-3-api-task
          CONTAINER_NAME: nestjs-hannibal-3-container
          IMAGE_TAG: ${{ github.sha }}
          ECR_REGISTRY: 258632448142.dkr.ecr.ap-northeast-1.amazonaws.com
          ECR_REPOSITORY: nestjs-hannibal-3
        run: |
          # 最新のタスク定義を取得
          TASK_DEF_ARN=$(aws ecs describe-services --cluster $CLUSTER_NAME --services $SERVICE_NAME --query "services[0].taskDefinition" --output text)
          aws ecs describe-task-definition --task-definition $TASK_DEF_ARN > task-def.json
          # イメージURIを書き換え
          NEW_IMAGE="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          cat task-def.json | jq --arg IMAGE "$NEW_IMAGE" --arg NAME "$CONTAINER_NAME" '(.taskDefinition.containerDefinitions[] | select(.name == $NAME) | .image) |= $IMAGE | .taskDefinition | {
            family,
            taskRoleArn,
            executionRoleArn,
            networkMode,
            containerDefinitions,
            volumes,
            placementConstraints,
            requiresCompatibilities,
            cpu,
            memory,
            tags,
            runtimePlatform
          } | with_entries(select(.value != null))' > new-task-def.json
          # 新しいタスク定義を登録
          TASK_DEF_ARN_NEW=$(aws ecs register-task-definition --cli-input-json file://new-task-def.json --query 'taskDefinition.taskDefinitionArn' --output text)
          # サービスを新タスク定義で更新
          aws ecs update-service --cluster $CLUSTER_NAME --service $SERVICE_NAME --task-definition $TASK_DEF_ARN_NEW

